<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
  <title>DRM leasing: VR for Wayland</title>
  <link rel="alternate" type="application/rss+xml" title="RSS" href="https://drewdevault.com/blog/index.xml">
  <link rel="icon" type="image/png" href="/avatar.png">
  
  <link rel="stylesheet" href="/main.min.d007a22f956a425cfa3f96c70ba325efd0f789fa65d2e609314f66cbe89ef0de.css">
</head>


<h1>
  DRM leasing: VR for Wayland
  <small>
    <span class="date">August 9, 2019</span>
    on
    <span class="site"><a href=".">Drew DeVault&#39;s blog</a></span>
  </small>
</h1>

<main>
  <article>
    <p>As those who read my <a href="/2019/07/15/Status-update-July-2019.html">status updates</a>
have been aware, recently I&rsquo;ve been working on bringing VR to Wayland (and vice
versa). The deepest and most technical part of this work is <em>DRM leasing</em>
(Direct Rendering Manager, <em>not</em> Digital Restrictions Management), and I think
it&rsquo;d be good to write in detail about what&rsquo;s involved in this part of the
effort. This work has been sponsored by <a href="https://status.im/">Status.im</a>, as part
of an effort to build a comprehensive Wayland-driven VR workspace. When we got
started, most of the plumbing was missing for VR headsets to be useful on
Wayland, so this has been my focus for a while. The result of this work is
summed up in this crappy handheld video:</p>
<video src="https://yukari.sr.ht/steamvr.webm" controls>
  Your web browser does not support the webm video codec. Please consider using
  web browsers that support free and open standards.
</video>
<p>Keith Packard, a long time Linux graphics developer, <a href="https://keithp.com/blogs/DRM-lease/">wrote several blog posts
documenting his work implementing this feature for
X11</a>. My journey was somewhat similar,
though thanks to his work I was able to save a lot of time. The rub of this idea
is that the Wayland compositor, the DRM (Direct Rendering Manager) master, can
&ldquo;lease&rdquo; some of its resources to a client so they can drive your display
directly. DRM is the kernel subsystem we use for enumerating and setting modes,
allocating pixel buffers, and presenting them in sync with the display&rsquo;s refresh
rate. For a number of reasons, minimizing latency being an important one, VR
applications prefer to do these tasks directly rather than be routed through the
display server like most applications are. The main tasks for implementing this
for Wayland were:</p>
<ol>
<li>Draft a <a href="https://lists.freedesktop.org/archives/wayland-devel/2019-July/040768.html">protocol extension</a> for issuing DRM leases</li>
<li>Write implementations for <a href="https://github.com/swaywm/wlroots/pull/1730">wlroots</a> and <a href="https://github.com/swaywm/sway/pull/4289">sway</a></li>
<li>Get a <a href="https://git.sr.ht/~sircmpwn/kmscube">simple test client</a> working</li>
<li>Draft a Vulkan extension for leasing via Wayland</li>
<li>Write an implementation for <a href="https://gitlab.freedesktop.org/mesa/mesa/merge_requests/1509">Mesa&rsquo;s Vulkan WSI implementation</a></li>
<li>Get a more complex <a href="https://git.sr.ht/~sircmpwn/xrgears">Vulkan test client</a> working</li>
<li>Add support to <a href="https://gitlab.freedesktop.org/xorg/xserver/merge_requests/248">Xwayland</a></li>
</ol>
<p>Let&rsquo;s break down exactly what was necessary for each of these steps.</p>
<h2 id="wayland-protocol-extension">Wayland protocol extension</h2>
<p>Writing a protocol extension was the first order of business. There was an
<a href="https://lists.freedesktop.org/archives/wayland-devel/2018-January/036652.html">earlier attempt</a> which petered off in January. I started
with this, by cleaning it up based on my prior experience writing protocols,
normalizing much of the terminology and style, and cleaning up the state
management. After some initial rounds of review, there were some questions to
answer. The most important ones were:</p>
<ul>
<li>How do we identify the display? Should we send the EDID, which may be
bigger than the maximum size of a Wayland message?</li>
<li>Are there security concerns? Could malicious clients read from framebuffers
they weren&rsquo;t given a lease for?</li>
</ul>
<p>The EDID I ended up sending in a side channel (file descriptor to shared
memory), and the latter was proven to be a non-issue by writing a malicious
client and demonstrating that the kernel rejects its attempts to do evil.</p>
<div class="highlight"><pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;event</span> <span class="na">name=</span><span class="s">&#34;edid&#34;</span><span class="nt">&gt;</span>
  <span class="nt">&lt;description</span> <span class="na">summary=</span><span class="s">&#34;edid&#34;</span><span class="nt">&gt;</span>
    The compositor may send this event once the connector is created to
    provide a file descriptor which may be memory-mapped to read the
    connector&#39;s EDID, to assist in selecting the correct connectors
    for lease. The fd must be mapped with MAP_PRIVATE by the recipient.

    Note that not all displays have an EDID, and this event will not be
    sent in such cases.
  <span class="nt">&lt;/description&gt;</span>
  <span class="nt">&lt;arg</span> <span class="na">name=</span><span class="s">&#34;edid&#34;</span> <span class="na">type=</span><span class="s">&#34;fd&#34;</span> <span class="na">summary=</span><span class="s">&#34;EDID file descriptor&#34;</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;arg</span> <span class="na">name=</span><span class="s">&#34;size&#34;</span> <span class="na">type=</span><span class="s">&#34;uint&#34;</span> <span class="na">summary=</span><span class="s">&#34;EDID size, in bytes&#34;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/event&gt;</span> 
</code></pre></div><p>A few more changes would happen to this protocol in the following weeks, but
this was good enough to move on to&hellip;</p>
<h2 id="wlroots--sway-implementation">wlroots &amp; sway implementation</h2>
<p>After a chat with Scott Anderson (the maintainer of DRM support in wlroots) and
thanks to his timely refactoring efforts, the stage was well set for introducing
this feature to wlroots. I had a good idea of how it would take shape. <a href="https://github.com/swaywm/wlroots/pull/1730/files#diff-77b17feac8a8af251811a20e5b9bbdd1">Half of
the work</a> - the state machine which maintains the server-side
view of the protocol - is well trodden ground and was fairly easy to put
together. Despite being a well-understood problem in the wlroots codebase, these
state machines are always a bit tedious to implement correctly, and I was still
to flushing out bugs well into the remainder of this workstream.</p>
<p>The other half of this work was in <a href="https://github.com/swaywm/wlroots/pull/1730/files#diff-8b05a774317ee8e87d51422170f82d4b">the DRM subsystem</a>. We
decided that we&rsquo;d have leased connectors appear &ldquo;destroyed&rdquo; to the compositor,
and thus the compositor would have an opportunity to clean it up and stop using
them, similar to the behavior of when an output is hotplugged. Further changes
were necessary to have the DRM internals elegantly carry around some state for
the leased connector and avoid using the connector itself, as well as dealing
with the termination of the lease (either by the client or by the compositor).
With all of this in place, it&rsquo;s a <a href="https://github.com/swaywm/wlroots/pull/1730/files#diff-8b05a774317ee8e87d51422170f82d4bR1601">simple matter</a> to enumerate
the DRM object IDs for all of the resources we intend to lease and issue the
lease itself.</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="n">nobjects</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nconns</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">wlr_drm_connector</span> <span class="o">*</span><span class="n">conn</span> <span class="o">=</span> <span class="n">conns</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="n">assert</span><span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">WLR_DRM_CONN_LEASED</span><span class="p">);</span>
	<span class="n">nobjects</span> <span class="o">+=</span> <span class="mi">0</span>
		<span class="o">+</span> <span class="mi">1</span> <span class="cm">/* connector */</span>
		<span class="o">+</span> <span class="mi">1</span> <span class="cm">/* crtc */</span>
		<span class="o">+</span> <span class="mi">1</span> <span class="cm">/* primary plane */</span>
		<span class="o">+</span> <span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">crtc</span><span class="o">-&gt;</span><span class="n">cursor</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">)</span> <span class="cm">/* cursor plane */</span>
		<span class="o">+</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">crtc</span><span class="o">-&gt;</span><span class="n">num_overlays</span><span class="p">;</span> <span class="cm">/* overlay planes */</span>
<span class="p">}</span>
<span class="k">if</span> <span class="p">(</span><span class="n">nobjects</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">wlr_log</span><span class="p">(</span><span class="n">WLR_ERROR</span><span class="p">,</span> <span class="s">&#34;Attempted DRM lease with &lt;= 0 objects&#34;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">wlr_log</span><span class="p">(</span><span class="n">WLR_DEBUG</span><span class="p">,</span> <span class="s">&#34;Issuing DRM lease with the %d objects:&#34;</span><span class="p">,</span> <span class="n">nobjects</span><span class="p">);</span>
<span class="n">uint32_t</span> <span class="n">objects</span><span class="p">[</span><span class="n">nobjects</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nconns</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">wlr_drm_connector</span> <span class="o">*</span><span class="n">conn</span> <span class="o">=</span> <span class="n">conns</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="n">objects</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
	<span class="n">objects</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">crtc</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
	<span class="n">objects</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">crtc</span><span class="o">-&gt;</span><span class="n">primary</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
	<span class="n">wlr_log</span><span class="p">(</span><span class="n">WLR_DEBUG</span><span class="p">,</span> <span class="s">&#34;connector: %d crtc: %d primary plane: %d&#34;</span><span class="p">,</span>
			<span class="n">conn</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">crtc</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">crtc</span><span class="o">-&gt;</span><span class="n">primary</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">crtc</span><span class="o">-&gt;</span><span class="n">cursor</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">wlr_log</span><span class="p">(</span><span class="n">WLR_DEBUG</span><span class="p">,</span> <span class="s">&#34;cursor plane: %d&#34;</span><span class="p">,</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">crtc</span><span class="o">-&gt;</span><span class="n">cursor</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
		<span class="n">objects</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">crtc</span><span class="o">-&gt;</span><span class="n">cursor</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">crtc</span><span class="o">-&gt;</span><span class="n">num_overlays</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">wlr_log</span><span class="p">(</span><span class="n">WLR_DEBUG</span><span class="p">,</span> <span class="s">&#34;+%zd overlay planes:&#34;</span><span class="p">,</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">crtc</span><span class="o">-&gt;</span><span class="n">num_overlays</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">crtc</span><span class="o">-&gt;</span><span class="n">num_overlays</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">objects</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">crtc</span><span class="o">-&gt;</span><span class="n">overlays</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
		<span class="n">wlr_log</span><span class="p">(</span><span class="n">WLR_DEBUG</span><span class="p">,</span> <span class="s">&#34;</span><span class="se">\t</span><span class="s">overlay plane: %d&#34;</span><span class="p">,</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">crtc</span><span class="o">-&gt;</span><span class="n">overlays</span><span class="p">[</span><span class="n">k</span><span class="p">]);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">lease_fd</span> <span class="o">=</span> <span class="n">drmModeCreateLease</span><span class="p">(</span><span class="n">backend</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span>
		<span class="n">objects</span><span class="p">,</span> <span class="n">nobjects</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">lessee_id</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">lease_fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">lease_fd</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">wlr_log</span><span class="p">(</span><span class="n">WLR_DEBUG</span><span class="p">,</span> <span class="s">&#34;Issued DRM lease %d&#34;</span><span class="p">,</span> <span class="o">*</span><span class="n">lessee_id</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nconns</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">wlr_drm_connector</span> <span class="o">*</span><span class="n">conn</span> <span class="o">=</span> <span class="n">conns</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="n">conn</span><span class="o">-&gt;</span><span class="n">lessee_id</span> <span class="o">=</span> <span class="o">*</span><span class="n">lessee_id</span><span class="p">;</span>
	<span class="n">conn</span><span class="o">-&gt;</span><span class="n">crtc</span><span class="o">-&gt;</span><span class="n">lessee_id</span> <span class="o">=</span> <span class="o">*</span><span class="n">lessee_id</span><span class="p">;</span>
	<span class="n">conn</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">WLR_DRM_CONN_LEASED</span><span class="p">;</span>
	<span class="n">conn</span><span class="o">-&gt;</span><span class="n">lease_terminated_cb</span> <span class="o">=</span> <span class="n">lease_terminated_cb</span><span class="p">;</span>
	<span class="n">conn</span><span class="o">-&gt;</span><span class="n">lease_terminated_data</span> <span class="o">=</span> <span class="n">lease_terminated_data</span><span class="p">;</span>
	<span class="n">wlr_output_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">output</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">lease_fd</span><span class="p">;</span>
</code></pre></div><p>The <a href="https://github.com/swaywm/sway/pull/4289">sway implementation</a> is very simple. I added a note in wlroots
which exposes whether or not an output is considered &ldquo;non-desktop&rdquo; (a property
which is set for most VR headsets), then sway just rigs up the lease manager and
offers all non-desktop outputs for lease.</p>
<h2 id="kmscube">kmscube</h2>
<p>Testing all of this required the use of a simple test client. During his earlier
work, Keith wrote some patches on top of
<a href="https://gitlab.freedesktop.org/mesa/kmscube/">kmscube</a>, a simple Mesa demo
which renders a spinning cube directly via DRM/KMS/GBM. A <a href="https://git.sr.ht/~sircmpwn/kmscube/commit/60d89ef1d9304427a1289174d9a311ab06e39b44">few simple
tweaks</a> was suitable to get this working through my protocol
extension, and for the first time I saw something rendered on my headset through
sway!</p>
<video src="https://yukari.sr.ht/vr.webm" controls>
  Your web browser does not support the webm video codec. Please consider using
  web browsers that support free and open standards.
</video>
<h2 id="vulkan">Vulkan</h2>
<p>Vulkan has a subsystem called WSI - Window System Integration - which handles
the linkage between Vulkan&rsquo;s rendering process and the underlying window system,
such as Wayland, X11, or win32. Keith added an extension to this system called
<a href="https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_EXT_acquire_xlib_display">VK_EXT_acquire_xlib_display</a>, which lives on top
of <a href="https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_EXT_direct_mode_display">VK_EXT_direct_mode_display</a>, a system for
driving displays directly with Vulkan. As the name implies, this system is
especially X11-specific, so I&rsquo;ve drafted my own VK extension for Wayland:
VK_EXT_acquire_wl_display. This is the crux of it:</p>
<div class="highlight"><pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;command</span> <span class="na">successcodes=</span><span class="s">&#34;VK_SUCCESS&#34;</span> <span class="na">errorcodes=</span><span class="s">&#34;VK_ERROR_INITIALIZATION_FAILED&#34;</span><span class="nt">&gt;</span>
  <span class="nt">&lt;proto&gt;&lt;type&gt;</span>VkResult<span class="nt">&lt;/type&gt;</span> <span class="nt">&lt;name&gt;</span>vkAcquireWaylandDisplayEXT<span class="nt">&lt;/name&gt;&lt;/proto&gt;</span>
  <span class="nt">&lt;param&gt;&lt;type&gt;</span>VkPhysicalDevice<span class="nt">&lt;/type&gt;</span> <span class="nt">&lt;name&gt;</span>physicalDevice<span class="nt">&lt;/name&gt;&lt;/param&gt;</span>
  <span class="nt">&lt;param&gt;</span>struct <span class="nt">&lt;type&gt;</span>wl_display<span class="nt">&lt;/type&gt;</span>* <span class="nt">&lt;name&gt;</span>display<span class="nt">&lt;/name&gt;&lt;/param&gt;</span>
  <span class="nt">&lt;param&gt;</span>struct <span class="nt">&lt;type&gt;</span>zwp_drm_lease_manager_v1<span class="nt">&lt;/type&gt;</span>* <span class="nt">&lt;name&gt;</span>manager<span class="nt">&lt;/name&gt;&lt;/param&gt;</span>
  <span class="nt">&lt;param&gt;&lt;type&gt;</span>int<span class="nt">&lt;/type&gt;</span> <span class="nt">&lt;name&gt;</span>nConnectors<span class="nt">&lt;/name&gt;&lt;/param&gt;</span>
  <span class="nt">&lt;param&gt;&lt;type&gt;</span>VkWaylandLeaseConnectorEXT<span class="nt">&lt;/type&gt;</span>* <span class="nt">&lt;name&gt;</span>pConnectors<span class="nt">&lt;/name&gt;&lt;/param&gt;</span>
<span class="nt">&lt;/command&gt;</span>
</code></pre></div><p>I chose to leave it up to the user to enumerate the leasable connectors from the
Wayland protocol, then populate these structs with references to the connectors
they want to lease:</p>
<div class="highlight"><pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;type</span> <span class="na">category=</span><span class="s">&#34;struct&#34;</span> <span class="na">name=</span><span class="s">&#34;VkWaylandLeaseConnectorEXT&#34;</span><span class="nt">&gt;</span>
  <span class="nt">&lt;member&gt;</span>struct <span class="nt">&lt;type&gt;</span>zwp_drm_lease_connector_v1<span class="nt">&lt;/type&gt;</span>* <span class="nt">&lt;name&gt;</span>pConnectorIn<span class="nt">&lt;/name&gt;&lt;/member&gt;</span>
  <span class="nt">&lt;member&gt;&lt;type&gt;</span>VkDisplayKHR<span class="nt">&lt;/type&gt;</span> <span class="nt">&lt;name&gt;</span>displayOut<span class="nt">&lt;/name&gt;&lt;/member&gt;</span>
<span class="nt">&lt;/type&gt;</span>
</code></pre></div><p>Again, this was the result of some iteration and design discussions with other
folks knowledgable in these topics. I owe special thanks to Daniel Stone for
sitting down with me (figuratively, on IRC) and going over ideas for how to
design the Vulkan API. Armed with this specification, I now needed a Vulkan
driver which supported it.</p>
<h2 id="implementing-the-vk-extension-in-mesa">Implementing the VK extension in Mesa</h2>
<p><a href="https://www.mesa3d.org/">Mesa</a> is the premier free software graphics suite
powering graphics on Linux and other operating systems. It includes an
implementation of OpenGL and Vulkan for several GPU vendors, and is the home of
the userspace end of AMDGPU, Intel, nouveau, and other graphics drivers. A
specification is nothing without its implementation, so I set out to
implementing this extension for Mesa. In the end, it turned out to be much
simpler than the corresponding X version. This is the complete code for the WSI
part of this feature:</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kt">void</span> <span class="nf">drm_lease_handle_lease_fd</span><span class="p">(</span>
      <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
      <span class="k">struct</span> <span class="n">zwp_drm_lease_v1</span> <span class="o">*</span><span class="n">zwp_drm_lease_v1</span><span class="p">,</span>
      <span class="n">int32_t</span> <span class="n">leased_fd</span><span class="p">)</span>
<span class="p">{</span>
   <span class="k">struct</span> <span class="n">wsi_display</span> <span class="o">*</span><span class="n">wsi</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
   <span class="n">wsi</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">leased_fd</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">drm_lease_handle_finished</span><span class="p">(</span>
      <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
      <span class="k">struct</span> <span class="n">zwp_drm_lease_v1</span> <span class="o">*</span><span class="n">zwp_drm_lease_v1</span><span class="p">)</span>
<span class="p">{</span>
   <span class="k">struct</span> <span class="n">wsi_display</span> <span class="o">*</span><span class="n">wsi</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">wsi</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">close</span><span class="p">(</span><span class="n">wsi</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">);</span>
      <span class="n">wsi</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">zwp_drm_lease_v1_listener</span> <span class="n">drm_lease_listener</span> <span class="o">=</span> <span class="p">{</span>
   <span class="n">drm_lease_handle_lease_fd</span><span class="p">,</span>
   <span class="n">drm_lease_handle_finished</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* VK_EXT_acquire_wl_display */</span>
<span class="n">VkResult</span>
<span class="nf">wsi_acquire_wl_display</span><span class="p">(</span><span class="n">VkPhysicalDevice</span> <span class="n">physical_device</span><span class="p">,</span>
                       <span class="k">struct</span> <span class="n">wsi_device</span> <span class="o">*</span><span class="n">wsi_device</span><span class="p">,</span>
                       <span class="k">struct</span> <span class="n">wl_display</span> <span class="o">*</span><span class="n">display</span><span class="p">,</span>
                       <span class="k">struct</span> <span class="n">zwp_drm_lease_manager_v1</span> <span class="o">*</span><span class="n">manager</span><span class="p">,</span>
                       <span class="kt">int</span> <span class="n">nConnectors</span><span class="p">,</span>
                       <span class="n">VkWaylandLeaseConnectorEXT</span> <span class="o">*</span><span class="n">connectors</span><span class="p">)</span>
<span class="p">{</span>
   <span class="k">struct</span> <span class="n">wsi_display</span> <span class="o">*</span><span class="n">wsi</span> <span class="o">=</span>
      <span class="p">(</span><span class="k">struct</span> <span class="n">wsi_display</span> <span class="o">*</span><span class="p">)</span> <span class="n">wsi_device</span><span class="o">-&gt;</span><span class="n">wsi</span><span class="p">[</span><span class="n">VK_ICD_WSI_PLATFORM_DISPLAY</span><span class="p">];</span>

   <span class="cm">/* XXX no support for mulitple leases yet */</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">wsi</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">VK_ERROR_INITIALIZATION_FAILED</span><span class="p">;</span>

   <span class="cm">/* XXX no support for mulitple connectors yet */</span>
   <span class="cm">/* The solution will eventually involve adding a listener to each
</span><span class="cm">    * connector, round tripping, and matching EDIDs once the lease is
</span><span class="cm">    * granted. */</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">nConnectors</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">VK_ERROR_INITIALIZATION_FAILED</span><span class="p">;</span>

   <span class="k">struct</span> <span class="n">zwp_drm_lease_request_v1</span> <span class="o">*</span><span class="n">lease_request</span> <span class="o">=</span>
      <span class="n">zwp_drm_lease_manager_v1_create_lease_request</span><span class="p">(</span><span class="n">manager</span><span class="p">);</span>
   <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nConnectors</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">zwp_drm_lease_request_v1_request_connector</span><span class="p">(</span><span class="n">lease_request</span><span class="p">,</span>
                                                 <span class="n">connectors</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pConnectorIn</span><span class="p">);</span>
   <span class="p">}</span>

   <span class="k">struct</span> <span class="n">zwp_drm_lease_v1</span> <span class="o">*</span><span class="n">drm_lease</span> <span class="o">=</span>
      <span class="n">zwp_drm_lease_request_v1_submit</span><span class="p">(</span><span class="n">lease_request</span><span class="p">);</span>
   <span class="n">zwp_drm_lease_request_v1_destroy</span><span class="p">(</span><span class="n">lease_request</span><span class="p">);</span>
   <span class="n">zwp_drm_lease_v1_add_listener</span><span class="p">(</span><span class="n">drm_lease</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">drm_lease_listener</span><span class="p">,</span> <span class="n">wsi</span><span class="p">);</span>
   <span class="n">wl_display_roundtrip</span><span class="p">(</span><span class="n">display</span><span class="p">);</span>

   <span class="k">if</span> <span class="p">(</span><span class="n">wsi</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">VK_ERROR_INITIALIZATION_FAILED</span><span class="p">;</span>

   <span class="kt">int</span> <span class="n">nconn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="n">drmModeResPtr</span> <span class="n">res</span> <span class="o">=</span> <span class="n">drmModeGetResources</span><span class="p">(</span><span class="n">wsi</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">);</span>
   <span class="n">drmModeObjectListPtr</span> <span class="n">lease</span> <span class="o">=</span> <span class="n">drmModeGetLease</span><span class="p">(</span><span class="n">wsi</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">);</span>
   <span class="k">for</span> <span class="p">(</span><span class="n">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">count_connectors</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">uint32_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">lease</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
         <span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">connectors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">lease</span><span class="o">-&gt;</span><span class="n">objects</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span>
         <span class="p">}</span>
         <span class="k">struct</span> <span class="n">wsi_display_connector</span> <span class="o">*</span><span class="n">connector</span> <span class="o">=</span>
            <span class="n">wsi_display_get_connector</span><span class="p">(</span><span class="n">wsi_device</span><span class="p">,</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">connectors</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
         <span class="cm">/* TODO: Match EDID with requested connector */</span>
         <span class="n">connectors</span><span class="p">[</span><span class="n">nconn</span><span class="p">].</span><span class="n">displayOut</span> <span class="o">=</span>
            <span class="n">wsi_display_connector_to_handle</span><span class="p">(</span><span class="n">connector</span><span class="p">);</span>
         <span class="o">++</span><span class="n">nconn</span><span class="p">;</span>
      <span class="p">}</span>
   <span class="p">}</span>
   <span class="n">drmModeFreeResources</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>

   <span class="k">return</span> <span class="n">VK_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>Rigging it up to each driver&rsquo;s WSI shim is pretty straightforward from this
point. I only did it for radv - AMD&rsquo;s Vulkan driver (cause that&rsquo;s the hardware I
was using at the time) - but the rest should be trivial to add. Equipped with a
driver in hand, it&rsquo;s time to make a Real VR Application work on Wayland.</p>
<h2 id="xrgears">xrgears</h2>
<p><a href="https://gitlab.com/lubosz/xrgears">xrgears</a> is another simple demo application
like kmscube - but designed to render a VR scene. It leverages Vulkan and
<a href="http://www.openhmd.net/">OpenHMD</a> (Open Head Mounted Display) to display this
scene and stick the camera to your head. With the Vulkan extension implemented,
it was a fairly simple matter to <a href="https://git.sr.ht/~sircmpwn/xrgears/commit/41ef1d1dfe3e56766d1f8b72b335567eb7842d04">rig up a Wayland backend</a>. The
result:</p>
<video src="https://yukari.sr.ht/xrgears.webm" controls>
  Your web browser does not support the webm video codec. Please consider using
  web browsers that support free and open standards.
</video>
<h2 id="xwayland">Xwayland</h2>
<p>The final step was to integrate this extension with Xwayland, so that X
applications which took advantage of Keith&rsquo;s work would work via Xwayland. This
ended up being more difficult than I expected for one reason in particular:
modes. Keith&rsquo;s Vulkan extension is designed in two steps:</p>
<ol>
<li>Convert an RandR output into a VkDisplayKHR</li>
<li>Acquire a lease for a set of VkDisplayKHRs</li>
</ol>
<p>Between these steps, you can query the modes (available resolutions and refresh
rates) of the display. However, the Wayland protocol I designed does not let you
query modes until <em>after</em> you get the DRM handle, at which point you should
query them through DRM, thus reducing the number of sources of truth and
simplifying things considerably. This is arguably a design misstep in the
original Vulkan extension, but it&rsquo;s shipped in a lot of software and is beyond
fixing. So how do we deal with it?</p>
<p>One way (which was suggested at one point) would be to change the protocol to
include the relevant mode information, so that Xwayland could populate the RandR
modes from it. I found this distasteful, because it was making the protocol more
complex for the sake of a legacy system. Another option would be to make a
second protocol which includes this extra information especially for Xwayland,
but this also seemed like a compromise that compositors would rather not make.
Yet another option would be to have Xwayland request a lease with zero objects
and scan connectors itself, but zero-object leases are not possible.</p>
<p>The option I ended up going with is to have Xwayland open the DRM device itself
and scan connectors there. This is less palatable because (1) we can&rsquo;t be sure
which DRM device is correct, and (2) we can&rsquo;t be sure Xwayland will have
permission to read it. We&rsquo;re still not sure how best to solve this in the long
term. As it stands, this approach is sufficient to get it working in the common
case. The code looks something like this:</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="n">RRModePtr</span> <span class="o">*</span>
<span class="nf">xwl_get_rrmodes_from_connector_id</span><span class="p">(</span><span class="n">int32_t</span> <span class="n">connector_id</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">nmode</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">npref</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">drmDevicePtr</span> <span class="n">devices</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="n">drmModeConnectorPtr</span> <span class="n">conn</span><span class="p">;</span>
    <span class="n">drmModeModeInfoPtr</span> <span class="n">kmode</span><span class="p">;</span>
    <span class="n">RRModePtr</span> <span class="o">*</span><span class="n">rrmodes</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">drm</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">pref</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

    <span class="o">*</span><span class="n">nmode</span> <span class="o">=</span> <span class="o">*</span><span class="n">npref</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/* TODO: replace with zero-object lease once kernel supports them */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">drmGetDevices2</span><span class="p">(</span><span class="n">DRM_NODE_PRIMARY</span><span class="p">,</span> <span class="n">devices</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span>
            <span class="o">||</span> <span class="o">!*</span><span class="n">devices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
        <span class="n">ErrorF</span><span class="p">(</span><span class="s">&#34;Failed to enumerate DRM devices&#34;</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">drm</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">devices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">O_RDONLY</span><span class="p">);</span>
    <span class="n">drmFreeDevices</span><span class="p">(</span><span class="n">devices</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

    <span class="n">conn</span> <span class="o">=</span> <span class="n">drmModeGetConnector</span><span class="p">(</span><span class="n">drm</span><span class="p">,</span> <span class="n">connector_id</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">conn</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">close</span><span class="p">(</span><span class="n">drm</span><span class="p">);</span>
        <span class="n">ErrorF</span><span class="p">(</span><span class="s">&#34;drmModeGetConnector failed&#34;</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">rrmodes</span> <span class="o">=</span> <span class="n">xallocarray</span><span class="p">(</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">count_modes</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">RRModePtr</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rrmodes</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">close</span><span class="p">(</span><span class="n">drm</span><span class="p">);</span>
        <span class="n">ErrorF</span><span class="p">(</span><span class="s">&#34;Failed to allocate connector modes&#34;</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* This spaghetti brought to you courtesey of xf86RandrR12.c
</span><span class="cm">     * It adds preferred modes first, then non-preferred modes */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">pref</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">pref</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pref</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">conn</span><span class="o">-&gt;</span><span class="n">count_modes</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">kmode</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">conn</span><span class="o">-&gt;</span><span class="n">modes</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">pref</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="p">((</span><span class="n">kmode</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">DRM_MODE_TYPE_PREFERRED</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">xRRModeInfo</span> <span class="n">modeInfo</span><span class="p">;</span>
                <span class="n">RRModePtr</span> <span class="n">rrmode</span><span class="p">;</span>

                <span class="n">modeInfo</span><span class="p">.</span><span class="n">nameLength</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">kmode</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

                <span class="n">modeInfo</span><span class="p">.</span><span class="n">width</span> <span class="o">=</span> <span class="n">kmode</span><span class="o">-&gt;</span><span class="n">hdisplay</span><span class="p">;</span>
                <span class="n">modeInfo</span><span class="p">.</span><span class="n">dotClock</span> <span class="o">=</span> <span class="n">kmode</span><span class="o">-&gt;</span><span class="n">clock</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>
                <span class="n">modeInfo</span><span class="p">.</span><span class="n">hSyncStart</span> <span class="o">=</span> <span class="n">kmode</span><span class="o">-&gt;</span><span class="n">hsync_start</span><span class="p">;</span>
                <span class="n">modeInfo</span><span class="p">.</span><span class="n">hSyncEnd</span> <span class="o">=</span> <span class="n">kmode</span><span class="o">-&gt;</span><span class="n">hsync_end</span><span class="p">;</span>
                <span class="n">modeInfo</span><span class="p">.</span><span class="n">hTotal</span> <span class="o">=</span> <span class="n">kmode</span><span class="o">-&gt;</span><span class="n">htotal</span><span class="p">;</span>
                <span class="n">modeInfo</span><span class="p">.</span><span class="n">hSkew</span> <span class="o">=</span> <span class="n">kmode</span><span class="o">-&gt;</span><span class="n">hskew</span><span class="p">;</span>

                <span class="n">modeInfo</span><span class="p">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">kmode</span><span class="o">-&gt;</span><span class="n">vdisplay</span><span class="p">;</span>
                <span class="n">modeInfo</span><span class="p">.</span><span class="n">vSyncStart</span> <span class="o">=</span> <span class="n">kmode</span><span class="o">-&gt;</span><span class="n">vsync_start</span><span class="p">;</span>
                <span class="n">modeInfo</span><span class="p">.</span><span class="n">vSyncEnd</span> <span class="o">=</span> <span class="n">kmode</span><span class="o">-&gt;</span><span class="n">vsync_end</span><span class="p">;</span>
                <span class="n">modeInfo</span><span class="p">.</span><span class="n">vTotal</span> <span class="o">=</span> <span class="n">kmode</span><span class="o">-&gt;</span><span class="n">vtotal</span><span class="p">;</span>
                <span class="n">modeInfo</span><span class="p">.</span><span class="n">modeFlags</span> <span class="o">=</span> <span class="n">kmode</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>

                <span class="n">rrmode</span> <span class="o">=</span> <span class="n">RRModeGet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">modeInfo</span><span class="p">,</span> <span class="n">kmode</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">rrmode</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">rrmodes</span><span class="p">[</span><span class="o">*</span><span class="n">nmode</span><span class="p">]</span> <span class="o">=</span> <span class="n">rrmode</span><span class="p">;</span>
                    <span class="o">*</span><span class="n">nmode</span> <span class="o">=</span> <span class="o">*</span><span class="n">nmode</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
                    <span class="o">*</span><span class="n">npref</span> <span class="o">=</span> <span class="o">*</span><span class="n">npref</span> <span class="o">+</span> <span class="n">pref</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">close</span><span class="p">(</span><span class="n">drm</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">rrmodes</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div><p>A simple update to the Wayland protocol was necessary to add the <code>CONNECTOR_ID</code>
atom to the RandR output, which is used by Mesa&rsquo;s Xlib WSI code for acquiring
the display, and was reused here to line up a connector offered by the Wayland
compositor with a connector found in the kernel. The <a href="https://gitlab.freedesktop.org/xorg/xserver/merge_requests/248">rest of the
changes</a> were pretty simple, and the result is that SteamVR works,
capping everything off nicely:</p>
<video src="https://yukari.sr.ht/steamvr.webm" controls>
  Your web browser does not support the webm video codec. Please consider using
  web browsers that support free and open standards.
</video>

  </article>
</main>

<section class="comment">
  

  <p>
  Have a comment on one of my posts? Start a discussion in my public inbox by
  sending an email to
  <a href="mailto:~sircmpwn/public-inbox@lists.sr.ht">~sircmpwn/public-inbox@lists.sr.ht</a>
  [<a href="https://man.sr.ht/lists.sr.ht/etiquette.md">mailing list etiquette</a>]
</section>

<section class="webring">
  <h2>
    Articles from blogs I read
    <small class="attribution">
      Generated by
      <a href="https://git.sr.ht/~sircmpwn/openring">openring</a>
    </small>
  </h2>
  <section class="articles">
    
    <div class="article">
      <h4 class="title">
        <a href="https://emersion.fr/blog/2020/status-update-21/" target="_blank" rel="noopener">Status update, August 2020</a>
      </h4>
      <p class="summary">Hi! Regardless of the intense heat I’ve been exposed to this last month,
I’ve still been able to get some stuff done (although having to move out to
another room which isn’t right under the roof).
I’ve worked a lot on IRC-related projects. I’ve added a znc-i…</p>
      <small class="source">
        via <a href="https://emersion.fr/blog/">emersion</a>
      </small>
      <small class="date">2020-08-19 00:00:00 &#43;0200 &#43;0200</small>
    </div>
    
    <div class="article">
      <h4 class="title">
        <a href="https://sourcehut.org/blog/2020-08-16-whats-cooking-august-2020/" target="_blank" rel="noopener">What&#39;s cooking on Sourcehut? August 2020</a>
      </h4>
      <p class="summary">Another month passes and we find ourselves writing (or reading) this status
update on a quiet, rainy Sunday morning. Today our userbase numbers 16,683
members strong, up 580 from last month. Please extend a kind welcome to our new
colleagues! Thanks for read…</p>
      <small class="source">
        via <a href="https://sourcehut.org/blog/">Blogs on Sourcehut</a>
      </small>
      <small class="date">2020-08-16 00:00:00 &#43;0000 &#43;0000</small>
    </div>
    
    <div class="article">
      <h4 class="title">
        <a href="https://blog.golang.org/go1.15" target="_blank" rel="noopener">Go 1.15 is released</a>
      </h4>
      <p class="summary">
  
  
    
      
        Today the Go team is very happy to announce the release of Go 1.15. You can get it from the download page.
Some of the highlights include:

Substantial improvements to the Go linker
Improved allocation for small objects at high core coun…</p>
      <small class="source">
        via <a href="https://blog.golang.org/feed.atom">The Go Programming Language Blog</a>
      </small>
      <small class="date">2020-08-11 11:00:00 &#43;0000 &#43;0000</small>
    </div>
    
    <div class="article">
      <h4 class="title">
        <a href="https://100r.co/site/north_pacific_logbook.html" target="_blank" rel="noopener">North Pacific Logbook</a>
      </h4>
      <p class="summary">
The passage from Japan (Shimoda) to Canada (Victoria) took 51 days, and it was the hardest thing we&#39;ve ever done. We decided to keep a logbook, to better remember it and so it can help others who wish to make this trip.Continue Reading
  </p>
      <small class="source">
        via <a href="https://100r.co/">Hundred Rabbits</a>
      </small>
      <small class="date">2020-07-31 00:00:00 &#43;0000 GMT</small>
    </div>
    
  </section>
</section>


<footer>
  The content for this site is
  <a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>.
  The <a href="https://git.sr.ht/~sircmpwn/drewdevault.com">code for this site</a>
  is <a href="https://opensource.org/licenses/MIT">MIT</a>.
</footer>

